;; author: bef0rewind
;; date: 2013-05-17
;; last-modified: 2013-05-18

(ns semantics-interpreter.core
  (:use clojure.test))



;; A BIP component definition
(def component-1 (atom
                  {:type 'atomic
                   :current "start"
                   :transitions [{:from "start" :to "end" :export "P"}
                                 {:from "start" :to "end" :export "S"}
                                 {:from "end" :to "start" :export "Q"}]}))
;; A BIP component definition
(def component-2 (atom
                  {:type 'atomic
                   :current "start"
                   :inner-transitions [{:from "start" :to "end" :inport "I"}]
                   :transitions [{:from "start" :to "end" :export "M"}
                                 {:from "end" :to "start" :export "N"}]}))

;; A BIP interaction definiction
(def interaction-1 (atom
                    {:type 'interaction
                     :bind-ports [{:component component-1 :export "P"}
                                  {:component component-2 :export "M"}]
                     :export "T"}))
;; A BIP interaction definiction
(def interaction-2 (atom
                    {:type 'interaction
                     :bind-ports [{:component component-1 :export "S"}]
                     :export "ES"}))

;; A BIP compound component definition
(def component-top (atom
                    {:type 'compound
                     :current "" ;; this key should not be used. why is it created?
                     :components [component-1 component-2 interaction-1]
                     :bind-ports [{:component component-1 :source "Q" :export "Q"}
                                  {:component component-1 :source "S" :export "S"}
                                  {:component component-2 :source "N" :export "N"}
                                  {:component interaction-1 :source "T" :export "T"}]
                     }))

(defn add-transition 
  [component t]
  (swap!))


;; list current enabled ports of a component
;; only works for atomic components
;; TODO: values generated by this function may be used many times in a macro-step
;;       so, async approach may be applied to this function, or make possible-ports
;;       a key of component structure.
(defn possible-ports
  [component]
  (cond (= 'atomic (component :type ))
        ;; ports of transitions whose source state is 'current' state
        (map :export (filter
                      #(= (% :from ) (component :current ))
                      (component :transitions )))

        (= 'compound (component :type ))
        ;; check exports connected to sub-components and connectors and list the enabled ones
        (map :export (filter
                      #(export-enable? (deref (% :component )) 
                                       (% :source ))
                      (component :bind-ports )))
        (= 'interaction (component :type ))
        ;; check if interaction is enabled and list its export
        (if (interaction-enable? component)
          [(component :export )]
          nil)))

(possible-ports @component-2)
(possible-ports @interaction-1)
(possible-ports @interaction-2)
(= ["S" "T"] (possible-ports @component-top))

;; TODO
;; a component has a enabled interaction (without export)
;; or a enabled component (not using its export)
(defn component-enable?
  [component]
  (case (:type component)
    atomic (in?
            (map :from (:inner-transitions component))
            (:current component))
    ;; every sub-component of a compound component is enable
    compound (reduce #(or %1 %2) false
                     (map (comp component-enable? deref)
                          (:components component)))
    interaction (if (not= nil (:export component))
                  false
                  (interaction-enable? component))))

(component-enable? @component-2)
(component-enable? @component-1)
(component-enable? @interaction-1)
(component-enable? @component-top)
(:type @component-1)





;; check whether a sequence has a specific value
;; return true or false
(defn in?
  "true if seq contains elm"
  [seq elm]
  (if (some #(= elm %) seq) true false))

;; check whether a export is enabled in a specific component
;; TODO: should consider interaction ports
;; return true or false
(defn export-enable?
  [component export]
  (in? (possible-ports component) export))

(export-enable? @component-1 "S")

(export-enable? @interaction-1 "T")
(deftest test-export-enable?
  (is (= true (export-enable? @component-1 "S"))))



;; check whether an interaction is enabled
;; return true or false
(defn interaction-enable?
  [interaction]
  (reduce #(and %1 %2) true
          (map (fn [item] (export-enable? (deref (item :component )) (item :export )))
               (interaction :bind-ports ))))


(interaction-enable? @interaction-1)
(interaction-enable? @interaction-2)

;; compute a possible next state of a top component
(defn bip-next-snapshot
  [component]
  component)

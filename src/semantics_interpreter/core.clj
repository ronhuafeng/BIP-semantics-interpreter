;; author: bef0rewind
;; date: 2013-05-17
;; last-modified: 2013-05-18

(ns semantics-interpreter.core)



;; A BIP component definition
(def component-1
  {:type 'atomic
   :current "start"
   :transitions [{:from "start" :to "end" :port "P"}
                 {:from "start" :to "end" :port "S"}
                 {:from "end" :to "start" :port "Q"}]})
;; A BIP component definition
(def component-2
  {:type 'atomic
   :current "start"
   :transitions [{:from "start" :to "end" :port "M"}
                 {:from "end" :to "start" :port "N"}]})

;; A BIP interaction definiction
(def interaction-1
  {:type 'interaction
   :bind-ports [{:component (var component-1) :port "P"}
                {:component (var component-2) :port "M"}]
   :export "T"})
;; A BIP interaction definiction
(def interaction-2
  {:type 'interaction
   :bind-ports [{:component (var component-1) :port "S"}]
   :export "ES"})

;; A BIP compound component definition
(def component-top
  {:type 'compound
   :current "" ;; this key should not be used. why is it created?
   :sub-components [(var component-1) (var component-2)]
   :interactions [{:interaction (var interaction-1)}]
   :bind-ports [{:component (var component-1) :source "Q" :port "Q"}
                {:component (var component-1) :source "S" :port "S"}
                {:component (var component-2) :source "N" :port "N"}
                {:component (var interaction-1) :source "T" :port "T"}]
   })

;; list current enabled ports of a component
;; only works for atomic components
;; TODO: values generated by this function may be used many times in a macro-step
;;       so, async approach may be applied to this function, or make possible-ports
;;       a key of component structure.
(defn possible-ports
  [component]
  (cond (= 'atomic (component :type ))
    ;; ports of transitions whose source state is 'current' state
    (map :port (filter
                 #(= (% :from ) (component :current ))
                 (component :transitions )))

    (= 'compound (component :type ))
    ;; check exports connected to sub-components and connectors and list the enabled ones
    (map :port (filter
                 #(port-enable? (% :component ) (% :source ))
                 (component :bind-ports )))
    (= 'interaction (component :type ))
    ;; check if interaction is enabled and list its export
    (if (interaction-enable? component)
      [(component :export )]
      nil)))

(possible-ports component-1)
(possible-ports interaction-1)
(possible-ports interaction-2)
(= ["S" "T"] (possible-ports component-top))

;; TODO
;; a component has a enabled interaction (without export)
;; or a enabled component (not using its export)
(defn component-enable?
  [component]
  (case (component :type )
    atomic (+ 1)
    compound (+ 2)
    interaction (+ 3)))
(= 'atomic 'compound)

(component-enable? component-1)





;; check whether a sequence has a specific value
;; return true or false
(defn in?
  "true if seq contains elm"
  [seq elm]
  (if (some #(= elm %) seq) true false))

;; check whether a port is enabled in a specific component
;; TODO: should consider interaction ports
;; return true or false
(defn port-enable?
  [component port]
  (in? (possible-ports component) port))

(port-enable? component-1 "S")
(port-enable? interaction-1 "T")




;; check whether an interaction is enabled
;; return true or false
(defn interaction-enable?
  [interaction]
  (reduce #(and %1 %2) true
    (map (fn [item] (port-enable? (item :component ) (item :port )))
      (interaction :bind-ports ))))


(interaction-enable? interaction-1)
(interaction-enable? interaction-2)

;; compute a possible next state of a top component
(defn bip-next-snapshot
  [component]
  component)

